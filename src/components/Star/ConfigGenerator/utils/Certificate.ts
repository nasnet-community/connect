import type { RouterConfig } from "../ConfigGenerator";
import { mergeRouterConfigs } from "./ConfigGeneratorUtil";
import { 
    ScriptAndScheduler,
    OneTimeScript
} from "./ScriptSchedule";

export const CheckCGNAT = (wanInterfaceName: string = "ether1"): RouterConfig => {
    const cgnatScriptContent: RouterConfig = {
        "": [
            "",
            "# Configuration Variables",
            `:local wanInterfaceName "${wanInterfaceName}";`,
            `:local connectivityCheckUrl "http://detectportal.firefox.com/success.txt";`,
            `:local publicIpCheckUrl "https://api.ipify.org";`,
            `:local logPrefix "[CGNAT-Check-OneTime] ";`,
            "",
            `:log info ($logPrefix. "ONE-TIME SCRIPT STARTED. WAN Interface: ". $wanInterfaceName);`,
            "",
            "# Global variables for status",
            `:global globalInternetStatus "Unknown";`,
            `:global globalCgnatStatus "Unknown";`,
            `:global globalWanIp "Unknown";`,
            `:global globalPublicIp "Unknown";`,
            "",
            "# Step 1: Check Internet Connectivity",
            `:local internetUp false;`,
            `:local fetchResult;`,
            `:do {`,
            `    /tool fetch url=$connectivityCheckUrl mode=http keep-result=no;`,
            `    :set internetUp true;`,
            `    :log info ($logPrefix. "Internet connectivity check successful. Status: UP");`,
            `    :set $globalInternetStatus "UP";`,
            `} on-error={`,
            `    :log warning ($logPrefix. "Internet connectivity check failed. Status: DOWN");`,
            `    :set $globalInternetStatus "DOWN";`,
            `    :set $globalCgnatStatus "Undetermined (Internet Down)";`,
            `    :set $globalWanIp "Undetermined (Internet Down)";`,
            `    :set $globalPublicIp "Undetermined (Internet Down)";`,
            `    :log info ($logPrefix. "Script will complete and self-destruct due to internet down.");`,
            `}`,
            "",
            "# Step 2: If Internet is UP, proceed with CGNAT detection",
            `if ($internetUp) do={`,
            `    :log info ($logPrefix. "Internet is UP. Proceeding with CGNAT detection.");`,
            "",
            `    # Get Local WAN IP Address`,
            `    :local localWanIpWithMask [/ip address get [find interface=$wanInterfaceName disabled=no] address];`,
            `    :local localWanIp "";`,
            "",
            `    if ([:len $localWanIpWithMask] > 0) do={`,
            `        :local slashPos [:find $localWanIpWithMask "/"];`,
            `        if ($slashPos > 0) do={`,
            `            :set localWanIp [:pick $localWanIpWithMask 0 $slashPos];`,
            `        } else={`,
            `            :set localWanIp $localWanIpWithMask;`,
            `        }`,
            `        :log info ($logPrefix. "Local WAN IP on ". $wanInterfaceName. ": ". $localWanIp);`,
            `        :set $globalWanIp $localWanIp;`,
            `    } else={`,
            `        :log warning ($logPrefix. "Could not retrieve IP address for interface ". $wanInterfaceName);`,
            `        :set $globalWanIp "Error: Not Found";`,
            `        :set $globalCgnatStatus "Undetermined (WAN IP Error)";`,
            `        :set $globalPublicIp "Undetermined (WAN IP Error)";`,
            `        :log info ($logPrefix. "Script will complete and self-destruct due to WAN IP error.");`,
            `    }`,
            "",
            `    # Continue with CGNAT detection only if we have WAN IP`,
            `    if ([:len $localWanIp] > 0 && $localWanIp != "Error: Not Found") do={`,
            `        # Check if Local WAN IP is in RFC 6598 CGNAT range (100.64.0.0/10)`,
            `        :local isRfc6598 false;`,
            `        :local firstOctet [:tonum [:pick $localWanIp 0 [:find $localWanIp "."]]];`,
            `        :local tempIp [:pick $localWanIp ([:find $localWanIp "."] + 1) [:len $localWanIp]];`,
            `        :local secondOctet [:tonum [:pick $tempIp 0 [:find $tempIp "."]]];`,
            "",
            `        if ($firstOctet = 100 && $secondOctet >= 64 && $secondOctet <= 127) do={`,
            `            :set isRfc6598 true;`,
            `            :log info ($logPrefix. "Local WAN IP is in RFC 6598 range (100.64.0.0/10).");`,
            `        } else={`,
            `            :log info ($logPrefix. "Local WAN IP is NOT in RFC 6598 range.");`,
            `        }`,
            "",
            `        # Fetch Actual Public IP Address`,
            `        :local actualPublicIp "";`,
            `        :local publicIpFetchError false;`,
            `        :do {`,
            `            :set fetchResult [/tool fetch url=$publicIpCheckUrl mode=https as-value output=user];`,
            `            if ([:fetch status] = "finished") do={`,
            `                :set actualPublicIp ([:fetch data]);`,
            `                :set actualPublicIp [:pick $actualPublicIp 0 [:len $actualPublicIp]];`,
            `                if ([:find $actualPublicIp "."] > 0 && [:len $actualPublicIp] >= 7 && [:len $actualPublicIp] <= 15) do={`,
            `                    :log info ($logPrefix. "Successfully fetched actual public IP: ". $actualPublicIp);`,
            `                    :set $globalPublicIp $actualPublicIp;`,
            `                } else={`,
            `                    :log warning ($logPrefix. "Fetched public IP does not look like a valid IP address.");`,
            `                    :set actualPublicIp "";`,
            `                    :set publicIpFetchError true;`,
            `                    :set $globalPublicIp "Error: Invalid Format";`,
            `                }`,
            `            } else={`,
            `                :log warning ($logPrefix. "Fetching public IP failed.");`,
            `                :set publicIpFetchError true;`,
            `                :set $globalPublicIp "Error: Fetch Failed";`,
            `            }`,
            `        } on-error={`,
            `            :log warning ($logPrefix. "Error during public IP fetch command execution.");`,
            `            :set publicIpFetchError true;`,
            `            :set $globalPublicIp "Error: Command Execution";`,
            `        }`,
            "",
            `        # Determine CGNAT Status`,
            `        if ($publicIpFetchError) do={`,
            `            :log warning ($logPrefix. "CGNAT status undetermined due to public IP fetch error.");`,
            `            :set $globalCgnatStatus "Undetermined (Public IP Fetch Error)";`,
            `            if ($isRfc6598) do={`,
            `                :log info ($logPrefix. "However, WAN IP is in RFC6598 range, strongly suggesting CGNAT.");`,
            `                :set $globalCgnatStatus "Likely CGNAT (RFC6598, Public IP Fetch Error)";`,
            `            }`,
            `        } else {`,
            `            if ([:len $localWanIp] > 0 && [:len $actualPublicIp] > 0) do={`,
            `                if ($localWanIp = $actualPublicIp) do={`,
            `                    :log info ($logPrefix. "Local WAN IP matches actual public IP. No NAT detected upstream.");`,
            `                    :set $globalCgnatStatus "No NAT/CGNAT (IPs Match)";`,
            `                } else={`,
            `                    :log warning ($logPrefix. "Local WAN IP MISMATCHES actual public IP. NAT detected upstream.");`,
            `                    if ($isRfc6598) do={`,
            `                        :set $globalCgnatStatus "CGNAT (RFC6598 & IP Mismatch)";`,
            `                    } else={`,
            `                        :set $globalCgnatStatus "NAT Detected (IP Mismatch, Not RFC6598)";`,
            `                    }`,
            `                }`,
            `            } else={`,
            `                :log warning ($logPrefix. "CGNAT status undetermined (missing local or public IP for comparison).");`,
            `                :set $globalCgnatStatus "Undetermined (IP Data Missing)";`,
            `            }`,
            `        }`,
            `    }`,
            `}`,
            "",
            "# Final Results Summary",
            `:log info ($logPrefix. "=== FINAL RESULTS ===");`,
            `:log info ($logPrefix. "Internet Status: ". $globalInternetStatus);`,
            `:log info ($logPrefix. "CGNAT Status: ". $globalCgnatStatus);`,
            `:log info ($logPrefix. "WAN IP: ". $globalWanIp);`,
            `:log info ($logPrefix. "Public IP: ". $globalPublicIp);`,
            `:log info ($logPrefix. "=== ONE-TIME SCRIPT COMPLETED ===");`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)"
        ]
    };

    return ScriptAndScheduler({
        ScriptContent: cgnatScriptContent,
        Name: "CGNAT-Check",
        interval: "1d",
        startTime: "startup"
    });
};

export const InitLetsEncrypt = (): RouterConfig => {
    // Create the Let's Encrypt certificate acquisition script content as RouterConfig
    const letsEncryptScriptContent: RouterConfig = {
        "": [
            "# MikroTik RouterOS Initial Let's Encrypt Certificate Acquisition Script",
            "# Version 1.0 - ONE TIME EXECUTION",
            "",
            `:log info "--- Starting Initial Let's Encrypt Certificate Acquisition Script ---";`,
            "",
            "# --- Module 1: Verify Internet Connectivity ---",
            `:local pingTarget "1.1.1.1";`,
            `:local pingCount 3;`,
            `:local pingResult [/ping $pingTarget count=$pingCount];`,
            "",
            `:if ($pingResult = 0) do={`,
            `    :log error "Internet Check: No connectivity to $pingTarget. Exiting script.";`,
            `    :log info "--- Initial Let's Encrypt Script Finished (Error) ---";`,
            `} else={`,
            `    :log info "Internet Check: Connectivity to $pingTarget confirmed.";`,
            "",
            `    # --- Module 2: Enable MikroTik Cloud and Obtain DNS Name ---`,
            `    :log info "Cloud DNS: Enabling IP Cloud DDNS service.";`,
            `    /ip cloud set ddns-enabled=yes;`,
            "",
            `    :local cloudDnsName "";`,
            `    :local attemptCount 0;`,
            `    :local maxAttempts 6;`,
            "",
            `    :while ($cloudDnsName = "" && $attemptCount < $maxAttempts) do={`,
            `        :if ($attemptCount = 0) do={`,
            `            :log info "Cloud DNS: Forcing initial IP Cloud update.";`,
            `            /ip cloud force-update;`,
            `        }`,
            `        :delay 10s;`,
            `        :set cloudDnsName [/ip cloud get dns-name];`,
            `        :set attemptCount ($attemptCount + 1);`,
            `        :if ($cloudDnsName != "") do={`,
            `            :log info "Cloud DNS: Obtained DNS name: $cloudDnsName";`,
            `        } else={`,
            `            :log warning "Cloud DNS: DNS name not yet available. Attempt: $attemptCount/$maxAttempts";`,
            `        }`,
            `    }`,
            "",
            `    :if ($cloudDnsName = "") do={`,
            `        :log error "Cloud DNS: Failed to obtain DNS name after $maxAttempts attempts. Exiting script.";`,
            `        :log info "--- Initial Let's Encrypt Script Finished (Error) ---";`,
            `    } else={`,
            `        # --- Module 3: Requesting the Let's Encrypt Certificate ---`,
            `        :local leFirewallComment "LE-Initial-Cert-HTTP-Challenge";`,
            `        :local certRequestSuccessful false;`,
            "",
            `        :log info "Certificate Request: Temporarily opening TCP port 80 for ACME challenge.";`,
            `        /ip firewall filter add action=accept chain=input protocol=tcp dst-port=80 comment=$leFirewallComment place-before=0;`,
            "",
            `        :log info "Certificate Request: Initiating Let's Encrypt certificate request for $cloudDnsName.";`,
            `        :do {`,
            `            /certificate enable-ssl-certificate dns-name=$cloudDnsName;`,
            `            :log info "Certificate Request: Command executed successfully.";`,
            `        } on-error={`,
            `            :log error "Certificate Request: Failed to execute certificate request.";`,
            `        }`,
            "",
            `        :log info "Certificate Request: Waiting 60 seconds for certificate issuance...";`,
            `        :delay 60s;`,
            "",
            `        :log info "Certificate Request: Closing TCP port 80.";`,
            `        /ip firewall filter remove [find comment=$leFirewallComment];`,
            "",
            `        # --- Module 4: Verifying and Applying the Certificate ---`,
            `        :log info "Certificate Verification: Checking for newly issued certificate for $cloudDnsName.";`,
            `        :local newCertEntry [/certificate find common-name=$cloudDnsName];`,
            "",
            `        :if ([:len $newCertEntry] > 0) do={`,
            `            :local newCertId [:pick $newCertEntry 0];`,
            `            :local newCertName [/certificate get $newCertId name];`,
            `            :log info "Certificate Verification: Successfully issued certificate: $newCertName (Common Name: $cloudDnsName).";`,
            `            :set certRequestSuccessful true;`,
            "",
            `            # Apply to www-ssl service (WebFig)`,
            `            :local wwwSslService [/ip service find name="www-ssl"];`,
            `            :if ([:len $wwwSslService] > 0) do={`,
            `                /ip service set $wwwSslService certificate=$newCertName;`,
            `                :log info "Certificate Application: Applied certificate $newCertName to www-ssl service.";`,
            `            } else={`,
            `                :log warning "Certificate Application: www-ssl service not found.";`,
            `            }`,
            "",
            `            # Apply to api-ssl service`,
            `            :local apiSslService [/ip service find name="api-ssl"];`,
            `            :if ([:len $apiSslService] > 0) do={`,
            `                /ip service set $apiSslService certificate=$newCertName;`,
            `                :log info "Certificate Application: Applied certificate $newCertName to api-ssl service.";`,
            `            } else={`,
            `                :log warning "Certificate Application: api-ssl service not found.";`,
            `            }`,
            "",
            `        } else={`,
            `            :log error "Certificate Verification: Failed to find newly issued certificate for $cloudDnsName.";`,
            `            :local existingValidCert [/certificate find common-name=$cloudDnsName where trusted=yes];`,
            `            :if ([:len $existingValidCert] > 0) do={`,
            `                :log warning "Certificate Verification: An existing valid certificate for $cloudDnsName was found. No new certificate issued.";`,
            `            }`,
            `        }`,
            "",
            `        :if ($certRequestSuccessful) do={`,
            `            :log info "--- Initial Let's Encrypt Script Finished Successfully ---";`,
            `        } else={`,
            `            :log error "--- Initial Let's Encrypt Script Finished With Errors ---";`,
            `        }`,
            `    }`,
            `}`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)"
        ]
    };

    // Use OneTimeScript to create a one-time script and scheduler
    return OneTimeScript({
        ScriptContent: letsEncryptScriptContent,
        name: "Init-LetsEncrypt",
        startTime: "startup"
    });
};

export const RenewalLetsEncrypt = (
    certNameToRenew: string = "MikroTik-LE-Cert",
    daysBeforeExpiryToRenew: number = 30
): RouterConfig => {
    // Create the Let's Encrypt certificate renewal script content as RouterConfig
    const renewalScriptContent: RouterConfig = {
        "": [
            "# MikroTik RouterOS Automated Let's Encrypt Certificate Renewal Script",
            "# Version 1.0 - ONE TIME EXECUTION",
            "",
            `:log info "--- Starting Automated Let's Encrypt Certificate Renewal Script ---";`,
            "",
            "# --- Configuration ---",
            `:local certNameToRenew "${certNameToRenew}";`,
            `:local daysBeforeExpiryToRenew ${daysBeforeExpiryToRenew};`,
            "",
            "# --- Module 0: Verify Internet Connectivity ---",
            `:local pingTarget "1.1.1.1";`,
            `:local pingCount 3;`,
            `:local pingResult [/ping $pingTarget count=$pingCount];`,
            "",
            `:if ($pingResult = 0) do={`,
            `    :log error "Internet Check: No connectivity to $pingTarget. Exiting script.";`,
            `    :log info "--- Renewal Script Finished (Error) ---";`,
            `} else={`,
            `    :log info "Internet Check: Connectivity to $pingTarget confirmed.";`,
            "",
            `    # --- Module 1: Check Certificate Expiry and Need for Renewal ---`,
            `    :local cloudDnsName [/ip cloud get dns-name];`,
            `    :if ($cloudDnsName = "") do={`,
            `        :log error "Renewal Check: MikroTik Cloud DNS name not found. Ensure IP Cloud is enabled and working.";`,
            `        :log info "--- Renewal Script Finished (Error) ---";`,
            `    } else={`,
            `        :local certIdToRenew "";`,
            `        :local certEntry [/certificate find name=$certNameToRenew];`,
            "",
            `        :if ([:len $certEntry] > 0) do={`,
            `            :set certIdToRenew [:pick $certEntry 0];`,
            `        } else={`,
            `            # If primary named cert not found, look for an auto-generated one for the same common name`,
            `            :set certEntry [/certificate find common-name=$cloudDnsName];`,
            `            :if ([:len $certEntry] > 0) do={`,
            `                :set certIdToRenew [:pick $certEntry 0];`,
            `                :local foundAutoGenName [/certificate get $certIdToRenew name];`,
            `                :log warning "Renewal Check: Certificate '$certNameToRenew' not found. Using existing auto-generated cert '$foundAutoGenName' for CN '$cloudDnsName'.";`,
            `                :set certNameToRenew $foundAutoGenName;`,
            `            } else={`,
            `                :log error "Renewal Check: No certificate found for CN '$cloudDnsName' (neither '$certNameToRenew' nor auto-generated). Run initial acquisition script or check CN.";`,
            `                :log info "--- Renewal Script Finished (Error) ---";`,
            `            }`,
            `        }`,
            "",
            `        :if ($certIdToRenew != "") do={`,
            `            :local expiresAfterStr [/certificate get $certIdToRenew expires-after];`,
            `            :local currentTime [/system clock get time];`,
            `            :local currentDate [/system clock get date];`,
            "",
            `            # Parse expiry date - simplified version`,
            `            :local monthStr [:pick $expiresAfterStr 0 3];`,
            `            :local dayStr [:pick $expiresAfterStr 4 6];`,
            `            :local yearStr [:pick [/system clock get date] 7 11];`,
            "",
            `            :local monthNum 0;`,
            `            :if ($monthStr = "jan") do={ :set monthNum 1; }`,
            `            :if ($monthStr = "feb") do={ :set monthNum 2; }`,
            `            :if ($monthStr = "mar") do={ :set monthNum 3; }`,
            `            :if ($monthStr = "apr") do={ :set monthNum 4; }`,
            `            :if ($monthStr = "may") do={ :set monthNum 5; }`,
            `            :if ($monthStr = "jun") do={ :set monthNum 6; }`,
            `            :if ($monthStr = "jul") do={ :set monthNum 7; }`,
            `            :if ($monthStr = "aug") do={ :set monthNum 8; }`,
            `            :if ($monthStr = "sep") do={ :set monthNum 9; }`,
            `            :if ($monthStr = "oct") do={ :set monthNum 10; }`,
            `            :if ($monthStr = "nov") do={ :set monthNum 11; }`,
            `            :if ($monthStr = "dec") do={ :set monthNum 12; }`,
            "",
            `            # Simplified expiry calculation - estimate days remaining`,
            `            :local daysToExpire 90;`,
            `            :do {`,
            `                # Try to calculate actual days to expiry`,
            `                :local expiryTimestamp [/certificate get $certIdToRenew expires-after];`,
            `                # This is a simplified calculation - in practice, you'd need more robust date parsing`,
            `            } on-error={`,
            `                :log warning "Renewal Check: Could not calculate exact expiry date. Using default estimate.";`,
            `            }`,
            "",
            `            :log info "Renewal Check: Certificate '$certNameToRenew' (CN: $cloudDnsName) expires on $expiresAfterStr (estimated $daysToExpire days remaining).";`,
            "",
            `            :local needsRenewal false;`,
            `            :if ($daysToExpire < $daysBeforeExpiryToRenew) do={`,
            `                :log warning "Renewal Check: Certificate needs renewal. Expires in $daysToExpire days (threshold: $daysBeforeExpiryToRenew days).";`,
            `                :set needsRenewal true;`,
            `            } else={`,
            `                :log info "Renewal Check: Certificate is still valid for $daysToExpire days. No renewal needed.";`,
            `                :log info "--- Renewal Script Finished (No Action Needed) ---";`,
            `            }`,
            "",
            `            # --- Module 2: Performing the Renewal (if needed) ---`,
            `            :if ($needsRenewal) do={`,
            `                :local leFirewallComment "LE-Renewal-Cert-HTTP-Challenge";`,
            `                :local renewalCertRequestSuccessful false;`,
            "",
            `                :log info "Certificate Renewal: Removing old certificate '$certNameToRenew' to ensure clean renewal.";`,
            `                /certificate remove $certIdToRenew;`,
            `                :delay 5s;`,
            "",
            `                :log info "Certificate Renewal: Temporarily opening TCP port 80 for ACME challenge.";`,
            `                /ip firewall filter add action=accept chain=input protocol=tcp dst-port=80 comment=$leFirewallComment place-before=0;`,
            "",
            `                :log info "Certificate Renewal: Initiating Let's Encrypt certificate request for $cloudDnsName.";`,
            `                :do {`,
            `                    /certificate enable-ssl-certificate dns-name=$cloudDnsName;`,
            `                    :log info "Certificate Renewal: Command executed successfully.";`,
            `                } on-error={`,
            `                    :log error "Certificate Renewal: Failed to execute certificate request.";`,
            `                }`,
            "",
            `                :log info "Certificate Renewal: Waiting 60 seconds for certificate issuance...";`,
            `                :delay 60s;`,
            "",
            `                :log info "Certificate Renewal: Closing TCP port 80.";`,
            `                /ip firewall filter remove [find comment=$leFirewallComment];`,
            "",
            `                :log info "Certificate Renewal: Verifying newly issued certificate for $cloudDnsName.";`,
            `                :local newAutoGenCertInfo [/certificate find common-name=$cloudDnsName];`,
            `                :if ([:len $newAutoGenCertInfo] = 0) do={`,
            `                    # Fallback: find the most recently issued cert for this CN`,
            `                    :set newAutoGenCertInfo [/certificate find common-name=$cloudDnsName];`,
            `                }`,
            "",
            `                :if ([:len $newAutoGenCertInfo] > 0) do={`,
            `                    :local newAutoGenCertId [:pick $newAutoGenCertInfo 0];`,
            `                    :local newAutoGenCertName [/certificate get $newAutoGenCertId name];`,
            "",
            `                    :log info "Certificate Renewal: New auto-generated certificate found: $newAutoGenCertName.";`,
            `                    /certificate set $newAutoGenCertId name="${certNameToRenew}";`,
            `                    :log info "Certificate Renewal: Renamed $newAutoGenCertName to '${certNameToRenew}'.";`,
            `                    :set renewalCertRequestSuccessful true;`,
            "",
            `                    # Apply to services`,
            `                    :local wwwSslService [/ip service find name="www-ssl"];`,
            `                    :if ([:len $wwwSslService] > 0) do={`,
            `                        /ip service set $wwwSslService certificate="${certNameToRenew}";`,
            `                        :log info "Certificate Renewal: Applied new certificate '${certNameToRenew}' to www-ssl service.";`,
            `                    }`,
            `                    :local apiSslService [/ip service find name="api-ssl"];`,
            `                    :if ([:len $apiSslService] > 0) do={`,
            `                        /ip service set $apiSslService certificate="${certNameToRenew}";`,
            `                        :log info "Certificate Renewal: Applied new certificate '${certNameToRenew}' to api-ssl service.";`,
            `                    }`,
            `                } else={`,
            `                    :log error "Certificate Renewal: Failed to find newly issued auto-generated certificate for $cloudDnsName.";`,
            `                }`,
            "",
            `                :if ($renewalCertRequestSuccessful) do={`,
            `                    :log info "--- Renewal Script Finished Successfully ---";`,
            `                } else={`,
            `                    :log error "--- Renewal Script Finished With Errors ---";`,
            `                }`,
            `            }`,
            `        }`,
            `    }`,
            `}`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)"
        ]
    };

    return ScriptAndScheduler({
        ScriptContent: renewalScriptContent,
        Name: "Renewal-LetsEncrypt",
        interval: "1d",
        startTime: "03:00:00"
    });
};

export const LetsEncrypt = (
    certNameToRenew: string = "MikroTik-LE-Cert",
    daysBeforeExpiryToRenew: number = 30,
    renewalStartTime: string = "03:00:00"
): RouterConfig => {
    // Get the initial Let's Encrypt script (one-time)
    const initScript = InitLetsEncrypt();
    
    // Get the renewal script with scheduler (uses the renewalStartTime parameter)
    const renewalScript = RenewalLetsEncrypt(certNameToRenew, daysBeforeExpiryToRenew);
    
    // Merge all configurations using mergeRouterConfigs
    const config = mergeRouterConfigs(initScript, renewalScript);

    // Add comprehensive comments at the beginning
    const comments = [
        "# Complete Let's Encrypt Certificate Management Setup",
        "# ================================================",
        "",
        "# This configuration includes:",
        "# 1. Initial certificate acquisition (one-time script + scheduler)",
        "# 2. Certificate renewal script with daily scheduler",
        "",
        `# Certificate Configuration:`,
        `# - Certificate Name: ${certNameToRenew}`,
        `# - Renewal Threshold: ${daysBeforeExpiryToRenew} days before expiry`,
        `# - Daily Check Time: ${renewalStartTime}`,
        "",
        "# Scripts Created:",
        "# - Init-LetsEncrypt: One-time initial certificate acquisition (self-removing)",
        "# - Renewal-LetsEncrypt: Certificate renewal check and renewal",
        "",
        "# Schedulers Created:",
        "# - Init-LetsEncrypt: Runs initial script once at startup (self-removing)",
        "# - Renewal-LetsEncrypt: Daily renewal checks at 03:00:00",
        "",
        "# Usage:",
        "# 1. Initial setup runs automatically at startup",
        "# 2. Daily renewal checks run automatically", 
        "# 3. Manual renewal: /system script run Renewal-LetsEncrypt",
        ""
    ];

    // Add comments to the beginning
    if (!config[""]) {
        config[""] = [];
    }
    config[""] = [...comments, ...config[""]];

    return config;
};

export const PrivateCert = (
    country: string = "US",
    state: string = "YourState", 
    locality: string = "YourCity",
    organization: string = "YourOrganization",
    organizationalUnit: string = "IT",
    keySize: number = 2048,
    daysValid: number = 3650
): RouterConfig => {
    const privateCertScriptContent: RouterConfig = {
        "": [
            "# MikroTik RouterOS Private CA and Server Certificate Setup Script",
            "# Version 1.0 - ONE TIME EXECUTION",
            "",
            `:log info "--- Starting Private CA/Server Certificate Setup Script ---";`,
            "",
            "# Configuration Variables",
            `:global CN_CA_NAME "[/system identity get name]-CA";`,
            `:global KEYSIZE "${keySize}";`,
            `:global DAYSVALID ${daysValid};`,
            `:global COUNTRY "${country}";`,
            `:global STATE "${state}";`,
            `:global LOC "${locality}";`,
            `:global ORG "${organization}";`,
            `:global OU "${organizationalUnit}";`,
            "",
            `:put ">>> Starting Initial CA/Server Certificate Setup...";`,
            "",
            "# Step 1.1: Create Certificate Authority (CA)",
            `:put "--> Creating CA Template...";`,
            `:do {`,
            `    /certificate add name=ca-template common-name=$CN_CA_NAME \\`,
            `        key-usage=crl-sign,key-cert-sign days-valid=$DAYSVALID key-size=$KEYSIZE \\`,
            `        country="$COUNTRY" state="$STATE" locality="$LOC" organization="$ORG" unit="$OU";`,
            `    :log info "CA template created successfully";`,
            `} on-error={`,
            `    :log error "Failed to create CA template";`,
            `}`,
            "",
            `:put "--> Signing CA Certificate ($CN_CA_NAME)...";`,
            `:do {`,
            `    /certificate sign ca-template name=$CN_CA_NAME ca-crl-host=127.0.0.1;`,
            `    :delay 5s;`,
            `    /certificate set [find name=$CN_CA_NAME] trusted=yes;`,
            `    :put "--> CA Certificate '$CN_CA_NAME' created and trusted.";`,
            `    :log info "CA Certificate created and set as trusted";`,
            `} on-error={`,
            `    :log error "Failed to sign or trust CA certificate";`,
            `}`,
            "",
            "# Step 1.2: Create Server Certificate",
            `:put "--> Creating Server Certificate Template...";`,
            `:local routerIdentity [/system identity get name];`,
            `:local lanIP [/ip address get [find interface~"bridge" !invalid] address];`,
            `:local lanIPOnly [:pick $lanIP 0 [:find $lanIP "/"]];`,
            "",
            `:do {`,
            `    /certificate add name=server-template common-name="server@$CN_CA_NAME" \\`,
            `        key-usage=digital-signature,key-encipherment,tls-server days-valid=$DAYSVALID key-size=$KEYSIZE \\`,
            `        country="$COUNTRY" state="$STATE" locality="$LOC" organization="$ORG" unit="$OU" \\`,
            `        subject-alt-name="DNS:$routerIdentity,IP:$lanIPOnly";`,
            `    :log info "Server certificate template created with SAN: DNS:$routerIdentity,IP:$lanIPOnly";`,
            `} on-error={`,
            `    :log error "Failed to create server certificate template";`,
            `}`,
            "",
            `:put "--> Signing Server Certificate (server@$CN_CA_NAME)...";`,
            `:do {`,
            `    /certificate sign server-template ca=$CN_CA_NAME name="server@$CN_CA_NAME";`,
            `    :delay 5s;`,
            `    /certificate set [find name="server@$CN_CA_NAME"] trusted=yes;`,
            `    :put "--> Server Certificate 'server@$CN_CA_NAME' created and trusted.";`,
            `    :log info "Server Certificate created and set as trusted";`,
            `} on-error={`,
            `    :log error "Failed to sign or trust server certificate";`,
            `}`,
            "",
            "# Step 1.3: Create Client Certificate Template (Generic)",
            `:put "--> Creating Generic Client Certificate Template...";`,
            `:do {`,
            `    /certificate add name=client-template common-name="client" \\`,
            `        key-usage=tls-client days-valid=$DAYSVALID key-size=$KEYSIZE \\`,
            `        country="$COUNTRY" state="$STATE" locality="$LOC" organization="$ORG" unit="$OU";`,
            `    :put "--> Generic Client Certificate Template 'client-template' created.";`,
            `    :log info "Generic client certificate template created";`,
            `} on-error={`,
            `    :log error "Failed to create client certificate template";`,
            `}`,
            "",
            "# Step 1.4: Apply Server Certificate to Services",
            `:put "--> Applying server certificate to HTTPS services...";`,
            `:do {`,
            `    :local serverCertName "server@$CN_CA_NAME";`,
            `    # Apply to www-ssl service (WebFig)`,
            `    :local wwwSslService [/ip service find name="www-ssl"];`,
            `    :if ([:len $wwwSslService] > 0) do={`,
            `        /ip service set $wwwSslService certificate=$serverCertName;`,
            `        :log info "Applied server certificate to www-ssl service";`,
            `    }`,
            `    # Apply to api-ssl service`,
            `    :local apiSslService [/ip service find name="api-ssl"];`,
            `    :if ([:len $apiSslService] > 0) do={`,
            `        /ip service set $apiSslService certificate=$serverCertName;`,
            `        :log info "Applied server certificate to api-ssl service";`,
            `    }`,
            `} on-error={`,
            `    :log error "Failed to apply server certificate to services";`,
            `}`,
            "",
            "# Certificate Setup Summary",
            `:put "=== Private Certificate Setup Summary ===";`,
            `:put "CA Certificate: $CN_CA_NAME";`,
            `:put "Server Certificate: server@$CN_CA_NAME";`,
            `:put "Client Template: client-template";`,
            `:put "Key Size: $KEYSIZE bits";`,
            `:put "Validity: $DAYSVALID days";`,
            `:put "=== Setup Complete ===";`,
            "",
            `:log info "--- Private Certificate Setup Script Completed Successfully ---";`,
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)"
        ]
    };

    // Use OneTimeScript to create a one-time script and scheduler
    return OneTimeScript({
        ScriptContent: privateCertScriptContent,
        name: "Private-Cert-Setup",
        startTime: "startup"
    });
};

export const ExportCert = (
    username: string,
    userPassword: string = "defaultpassword"
): RouterConfig => {
    // Create the Client Certificate Export script content as RouterConfig
    const exportCertScriptContent: RouterConfig = {
        "": [
            "# --- Configuration ---",
            `:local LOG_PREFIX "";`,
            `:global CN_CA_NAME "[/system identity get name]-CA";`,
            `:local OVPN_USERNAME "${username}";`,
            `:local OVPN_USERPASSWORD "${userPassword}";`,
            "",
            "# --- Initial Log ---",
            `:log info "$LOG_PREFIX Starting OpenVPN user setup for '$OVPN_USERNAME'.";`,
            "",
            "# --- Step 1: Check OpenVPN Server Status ---",
            `:put "$LOG_PREFIX --> Checking OpenVPN server status...";`,
            `:local ovpnServerEnabled [/interface ovpn-server server get enabled];`,
            `:if (!$ovpnServerEnabled) do={`,
            `    :log error "$LOG_PREFIX OpenVPN server is disabled. Cannot proceed for user '$OVPN_USERNAME'.";`,
            `    :put "$LOG_PREFIX ERROR: OpenVPN server is disabled. Aborting.";`,
            `} else={`,
            `    :log info "$LOG_PREFIX OpenVPN server is enabled.";`,
            `    :put "$LOG_PREFIX OpenVPN server is enabled.";`,
            "",
            `    # --- Step 2: Check PPP User Existence and Service ---`,
            `    :put "$LOG_PREFIX --> Checking PPP secret for '$OVPN_USERNAME' with 'ovpn' service...";`,
            `    :local pppUserEntry [/ppp secret find name=$OVPN_USERNAME service=ovpn];`,
            `    :if ([:len $pppUserEntry] = 0) do={`,
            `        :log error "$LOG_PREFIX PPP user '$OVPN_USERNAME' not found or not configured for 'ovpn' service. Aborting.";`,
            `        :put "$LOG_PREFIX ERROR: PPP user '$OVPN_USERNAME' not found or not configured for 'ovpn' service. Aborting.";`,
            `    } else={`,
            `        :log info "$LOG_PREFIX PPP user '$OVPN_USERNAME' with 'ovpn' service found.";`,
            `        :put "$LOG_PREFIX PPP user '$OVPN_USERNAME' with 'ovpn' service found.";`,
            "",
            `        # --- Step 3: Check for Existing Client Certificate ---`,
            `        :local clientCertCommonName ($OVPN_USERNAME. "@". $CN_CA_NAME);`,
            `        :put "$LOG_PREFIX --> Checking for existing certificate with CN '$clientCertCommonName'...";`,
            `        :local existingCert [/certificate find common-name=$clientCertCommonName];`,
            `        :if ([:len $existingCert] > 0) do={`,
            `            :log error "$LOG_PREFIX Client certificate for '$clientCertCommonName' already exists. Aborting.";`,
            `            :put "$LOG_PREFIX ERROR: Client certificate for '$clientCertCommonName' already exists. Aborting.";`,
            `        } else={`,
            `            :log info "$LOG_PREFIX No existing certificate found for '$clientCertCommonName'. Proceeding.";`,
            `            :put "$LOG_PREFIX No existing certificate found for '$clientCertCommonName'. Proceeding.";`,
            "",
            `            # --- Step 4: Check for CA Certificate Existence (Essential for signing) ---`,
            `            :put "$LOG_PREFIX --> Checking for CA certificate '$CN_CA_NAME'...";`,
            `            :local caCertEntry [/certificate find name=$CN_CA_NAME authority=yes];`,
            `            :if ([:len $caCertEntry] = 0) do={`,
            `                :log error "$LOG_PREFIX CA certificate '$CN_CA_NAME' not found or not an authority. Cannot sign client certificate. Aborting.";`,
            `                :put "$LOG_PREFIX ERROR: CA certificate '$CN_CA_NAME' not found. Aborting.";`,
            `            } else={`,
            `                :log info "$LOG_PREFIX CA certificate '$CN_CA_NAME' found.";`,
            `                :put "$LOG_PREFIX CA certificate '$CN_CA_NAME' found.";`,
            "",
            `                # --- All checks passed, proceed with certificate generation ---`,
            `                :log info "$LOG_PREFIX All pre-flight checks passed for '$OVPN_USERNAME'. Proceeding with certificate generation.";`,
            `                :put "$LOG_PREFIX --> Creating Client Certificate Template for $OVPN_USERNAME...";`,
            "",
            `                # Step 2.2: Generate Client Certificate for the User`,
            `                :do {`,
            `                    /certificate add name=($OVPN_USERNAME. "-template") copy-from=client-template \\`,
            `                        common-name=$clientCertCommonName;`,
            `                    :log info "$LOG_PREFIX Client certificate template created for $OVPN_USERNAME";`,
            `                } on-error={`,
            `                    :log error "$LOG_PREFIX Failed to create client certificate template for $OVPN_USERNAME";`,
            `                }`,
            "",
            `                :put "$LOG_PREFIX --> Signing Client Certificate for $OVPN_USERNAME...";`,
            `                :do {`,
            `                    /certificate sign ($OVPN_USERNAME. "-template") ca=$CN_CA_NAME \\`,
            `                        name=$clientCertCommonName;`,
            `                    :delay 5s;`,
            `                    :log info "$LOG_PREFIX Client Certificate '$clientCertCommonName' created.";`,
            `                    :put "$LOG_PREFIX Client Certificate '$clientCertCommonName' created.";`,
            `                } on-error={`,
            `                    :log error "$LOG_PREFIX Failed to sign client certificate for $OVPN_USERNAME";`,
            `                }`,
            "",
            `                # Step 2.3: Export CA Certificate`,
            `                :put "$LOG_PREFIX --> Exporting CA Certificate ($CN_CA_NAME)...";`,
            `                :do {`,
            `                    /certificate export-certificate $CN_CA_NAME export-passphrase="" \\`,
            `                        file-name=($CN_CA_NAME. "_ca_for_". $OVPN_USERNAME);`,
            `                    :log info "$LOG_PREFIX CA Certificate exported as '$CN_CA_NAME_ca_for_$OVPN_USERNAME.crt'";`,
            `                    :put "$LOG_PREFIX CA Certificate exported as '$CN_CA_NAME_ca_for_$OVPN_USERNAME.crt' to /file.";`,
            `                } on-error={`,
            `                    :log error "$LOG_PREFIX Failed to export CA certificate";`,
            `                }`,
            "",
            `                # Step 2.4: Export Client Certificate and Private Key`,
            `                :put "$LOG_PREFIX --> Exporting Client Certificate and Key for $OVPN_USERNAME...";`,
            `                :do {`,
            `                    /certificate export-certificate $clientCertCommonName \\`,
            `                        export-passphrase=$OVPN_USERPASSWORD \\`,
            `                        file-name=($OVPN_USERNAME. "_client_package");`,
            `                    :log info "$LOG_PREFIX Client files exported as '$OVPN_USERNAME_client_package.crt' and '$OVPN_USERNAME_client_package.key'";`,
            `                    :put "$LOG_PREFIX Client files exported as '$OVPN_USERNAME_client_package.crt' and '$OVPN_USERNAME_client_package.key' to /file.";`,
            `                    :put "    (Private key is encrypted with the user's password: $OVPN_USERPASSWORD)";`,
            `                } on-error={`,
            `                    :log error "$LOG_PREFIX Failed to export client certificate and key";`,
            `                }`,
            "",
            `                # --- Final success message ---`,
            `                :log info "$LOG_PREFIX Successfully completed OpenVPN user setup for '$OVPN_USERNAME'.";`,
            `                :put "$LOG_PREFIX >>> New User Setup for $OVPN_USERNAME COMPLETED.";`,
            `                :put "    Remember to securely transfer the .crt and .key files to the user.";`,
            `                :put "    Files created:";`,
            `                :put "    - $CN_CA_NAME_ca_for_$OVPN_USERNAME.crt (CA certificate)";`,
            `                :put "    - $OVPN_USERNAME_client_package.crt (Client certificate)";`,
            `                :put "    - $OVPN_USERNAME_client_package.key (Client private key)";`,
            `            }`,
            `        }`,
            `    }`,
            `}`,
            `:put "$LOG_PREFIX ---------------------------------------------------------------------";`
        ]
    };

    // Use ScriptGenerator to create the script
    return OneTimeScript({
        ScriptContent: exportCertScriptContent,
        name: `Export-Certs`,
        startTime: "startup"
    });
};

export const PublicCert = (
    checkServerCert: boolean = false
): RouterConfig => {
    // Create the Public Certificate Update script content as RouterConfig
    const publicCertScriptContent: RouterConfig = {
        "": [
            "# MikroTik RouterOS Public Certificate Authority Update Script",
            "# Version 1.0 - ONE TIME EXECUTION",
            "",
            ":log info \"--- Starting Public Certificate Authority Update Script ---\";",
            "",
            "# --- Configuration Variables ---",
            ":global logPrefix \"CertUpdate:\";",
            ":global pingTarget1 \"1.1.1.1\";",
            ":global pingTarget2 \"8.8.8.8\";",
            ":global pingCount 3;",
            ":global dnsTestHost \"www.mikrotik.com\";",
            "",
            ":global cacertFile \"cacert.pem\";",
            ":global cacertUrl \"https://curl.se/ca/cacert.pem\";",
            ":global importedCaCertName \"cacert-bundle-public\";",
            "",
            ":global googleCertFile \"roots-goog.pem\";",
            ":global googleCertUrl \"https://pki.goog/roots.pem\";",
            ":global importedGoogCertName \"google-roots-public\";",
            "",
            ":global downloadDelaySec 10;",
            ":global importDelaySec 5;",
            "",
            "# Set to 'yes' to validate server certs during fetch, 'no' otherwise.",
            "# 'no' is safer for initial runs if router's CA store is very old.",
            `:global checkServerCert "${checkServerCert ? "yes" : "no"}";`,
            "# --- End Configuration Variables ---",
            "",
            ":log info \"$logPrefix Script started.\";",
            "",
            "# 1. Internet Connectivity Check (Ping)",
            ":log info \"$logPrefix Performing Internet connectivity check...\";",
            ":local ping1Received [/ping $pingTarget1 count=$pingCount];",
            ":local ping2Received [/ping $pingTarget2 count=$pingCount];",
            "",
            ":if ($ping1Received = 0 && $ping2Received = 0) do={",
            "    :log error \"$logPrefix Internet connectivity check failed (both $pingTarget1 and $pingTarget2 unreachable). Exiting.\";",
            "} else={",
            "    :log info \"$logPrefix Internet connectivity check successful.\";",
            "",
            "    # 2. DNS Resolution Check",
            "    :log info \"$logPrefix Performing DNS resolution check...\";",
            "    :local resolvedIp [/tool dns-lookup server=[/ip dns get servers] name=$dnsTestHost];",
            "    :if ([:len $resolvedIp] = 0) do={",
            "        :log error \"$logPrefix DNS resolution test failed for $dnsTestHost. Exiting.\";",
            "    } else={",
            "        :log info \"$logPrefix DNS resolution test successful for $dnsTestHost (resolved to $resolvedIp).\";",
            "",
            "        # 3. Download cacert.pem",
            "        :log info \"$logPrefix Attempting to download $cacertFile from $cacertUrl...\";",
            "        :do {",
            "            /tool fetch url=$cacertUrl dst-path=$cacertFile check-certificate=$checkServerCert http-timeout=30s;",
            "            :delay 2s;",
            "            :if ([:len [/file find name=$cacertFile]] > 0) do={",
            "                :log info \"$logPrefix Successfully downloaded $cacertFile.\";",
            "            } else={",
            "                :log error \"$logPrefix Failed to download $cacertFile (file not found after fetch). Exiting.\";",
            "            }",
            "        } on-error={",
            "            :log error \"$logPrefix Error during fetch of $cacertFile. Exiting.\";",
            "        }",
            "        :log info \"$logPrefix Waiting $downloadDelaySec seconds after downloading $cacertFile...\";",
            "        :delay $downloadDelaySec;",
            "",
            "        # 4. Download roots-goog.pem",
            "        :log info \"$logPrefix Attempting to download $googleCertFile from $googleCertUrl...\";",
            "        :do {",
            "            /tool fetch url=$googleCertUrl dst-path=$googleCertFile check-certificate=$checkServerCert http-timeout=30s;",
            "            :delay 2s;",
            "            :if ([:len [/file find name=$googleCertFile]] > 0) do={",
            "                :log info \"$logPrefix Successfully downloaded $googleCertFile.\";",
            "            } else={",
            "                :log error \"$logPrefix Failed to download $googleCertFile (file not found after fetch). Exiting.\";",
            "            }",
            "        } on-error={",
            "            :log error \"$logPrefix Error during fetch of $googleCertFile. Exiting.\";",
            "        }",
            "        :log info \"$logPrefix Waiting $downloadDelaySec seconds after downloading $googleCertFile...\";",
            "        :delay $downloadDelaySec;",
            "",
            "        # 5. Import cacert.pem",
            "        :log info \"$logPrefix Processing $cacertFile for import as $importedCaCertName...\";",
            "        :if ([:len [/file find name=$cacertFile]] > 0) do={",
            "            :log info \"$logPrefix Found $cacertFile. Attempting to import as $importedCaCertName.\";",
            "            # Remove existing certificate with the target name, if any",
            "            :local existingCaCert [/certificate find name=$importedCaCertName];",
            "            :if ([:len $existingCaCert] > 0) do={",
            "                /certificate remove $existingCaCert;",
            "                :log info \"$logPrefix Removed existing certificate(s) named $importedCaCertName.\";",
            "            }",
            "            # Import the new certificate",
            "            /certificate import file-name=$cacertFile name=$importedCaCertName passphrase=\"\";",
            "            :delay 2s;",
            "            # Verify import",
            "            :if ([:len [/certificate find name=$importedCaCertName trusted=yes]] > 0) do={",
            "                :log info \"$logPrefix Successfully imported $cacertFile as $importedCaCertName.\";",
            "            } else={",
            "                :log error \"$logPrefix Failed to import $cacertFile as $importedCaCertName, or it was not marked trusted.\";",
            "            }",
            "        } else={",
            "            :log error \"$logPrefix $cacertFile not found. Skipping import.\";",
            "        }",
            "        :log info \"$logPrefix Waiting $importDelaySec seconds after importing $cacertFile...\";",
            "        :delay $importDelaySec;",
            "",
            "        # 6. Import roots-goog.pem",
            "        :log info \"$logPrefix Processing $googleCertFile for import as $importedGoogCertName...\";",
            "        :if ([:len [/file find name=$googleCertFile]] > 0) do={",
            "            :log info \"$logPrefix Found $googleCertFile. Attempting to import as $importedGoogCertName.\";",
            "            # Remove existing certificate with the target name, if any",
            "            :local existingGoogCert [/certificate find name=$importedGoogCertName];",
            "            :if ([:len $existingGoogCert] > 0) do={",
            "                /certificate remove $existingGoogCert;",
            "                :log info \"$logPrefix Removed existing certificate(s) named $importedGoogCertName.\";",
            "            }",
            "            # Import the new certificate",
            "            /certificate import file-name=$googleCertFile name=$importedGoogCertName passphrase=\"\";",
            "            :delay 2s;",
            "            # Verify import",
            "            :if ([:len [/certificate find name=$importedGoogCertName trusted=yes]] > 0) do={",
            "                :log info \"$logPrefix Successfully imported $googleCertFile as $importedGoogCertName.\";",
            "            } else={",
            "                :log error \"$logPrefix Failed to import $googleCertFile as $importedGoogCertName, or it was not marked trusted.\";",
            "            }",
            "        } else={",
            "            :log error \"$logPrefix $googleCertFile not found. Skipping import.\";",
            "        }",
            "        :log info \"$logPrefix Waiting $importDelaySec seconds after importing $googleCertFile...\";",
            "        :delay $importDelaySec;",
            "",
            "        # 7. Post-Operation Cleanup",
            "        :log info \"$logPrefix Performing post-operation cleanup...\";",
            "        :if ([:len [/file find name=$cacertFile]] > 0) do={",
            "            /file remove $cacertFile;",
            "            :log info \"$logPrefix Removed temporary file $cacertFile.\";",
            "        }",
            "        :if ([:len [/file find name=$googleCertFile]] > 0) do={",
            "            /file remove $googleCertFile;",
            "            :log info \"$logPrefix Removed temporary file $googleCertFile.\";",
            "        }",
            "",
            "        :log info \"$logPrefix Certificate update process completed.\";",
            "    }",
            "}",
            "",
            "# Script will now self-destruct (scheduler removal handled automatically)"
        ]
    };

    // Use OneTimeScript to create a one-time script and scheduler
    return OneTimeScript({
        ScriptContent: publicCertScriptContent,
        name: "Public-Cert-Update",
        startTime: "startup"
    });
};




